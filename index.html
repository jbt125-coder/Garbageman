<!DOCTYPE html>
<html>
<head>
    <title>Spy Jumper: Steering Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #05050a; overflow: hidden; font-family: 'Courier New', monospace; touch-action: none; color: white; }
        canvas { display: block; border-bottom: 8px solid #111; }
        
        .controls { position: absolute; bottom: 15px; width: 100%; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; z-index: 20; align-items: flex-end; }
        
        /* Steering Wheel Styling */
        #wheel-container { width: 140px; height: 140px; position: relative; display: flex; align-items: center; justify-content: center; }
        #wheel { 
            width: 120px; height: 120px; border: 8px solid #666; border-radius: 50%; 
            position: relative; transition: transform 0.1s linear; 
            background: radial-gradient(circle, #222 20%, transparent 21%);
        }
        #wheel::before { content: ""; position: absolute; top: 50%; left: 0; width: 100%; height: 8px; background: #666; margin-top: -4px; }
        
        .btn-group { display: flex; gap: 8px; }
        .btn { width: 65px; height: 65px; background: rgba(255,255,255,0.2); border: 2px solid white; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; user-select: none; font-size: 11px; font-weight: bold; }
        
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.85); padding: 10px; border: 1px solid #0f0; font-size: 11px; z-index: 10; border-radius: 5px;}
        #unmute-shield { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.9); z-index: 1000; display: flex; align-items: center; justify-content: center; }
    </style>
</head>
<body onclick="unlockAudio()">

<div id="unmute-shield">
    <div style="text-align:center">
        <div style="font-size:50px">üé°üèéÔ∏è</div>
        <p>TAP TO START ENGINE</p>
    </div>
</div>

<div id="ui">
    <span id="stg">STAGE 1</span> | HP: <span id="hp">100%</span><br>
    SQUASHED: <span id="sq">0</span>/10 | GEAR: <span id="gr">0</span>
</div>

<div id="player" style="position:absolute; top:-999px"></div>
<canvas id="gameCanvas"></canvas>

<div class="controls">
    <!-- VIRTUAL STEERING WHEEL -->
    <div id="wheel-container">
        <div id="wheel"></div>
    </div>

    <!-- ACTION BUTTONS -->
    <div class="btn-group">
        <div class="btn" id="gas" style="background:red">GAS</div>
        <div class="btn" id="jump" style="background:green">JUMP</div>
        <div class="btn" id="drop" style="background:orange">DROP</div>
    </div>
</div>

<script src="https://www.youtube.com"></script>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = 450;

let stage = 1, health = 100, squashes = 0, gear = 0, isGameOver = false;
let player = { x: canvas.width/2, y: 350, w: 60, h: 25, dy: 0, speed: 0, targetSpeed: 0 };
let enemies = [], bags = [], buildings = [];
let spawnTimer = 0, bgCityX = 0;

// STEERING LOGIC
let wheelAngle = 0;
let isSteering = false;
const wheelEl = document.getElementById('wheel');
const wheelCont = document.getElementById('wheel-container');

function handleSteer(e) {
    const touch = e.touches ? e.touches[0] : e;
    const rect = wheelCont.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const angle = Math.atan2(touch.clientY - centerY, touch.clientX - centerX);
    
    wheelAngle = angle;
    wheelEl.style.transform = `rotate(${angle}rad)`;
    
    // Convert angle to horizontal movement (-1 to 1 range)
    let steerPower = Math.cos(angle);
    player.x += steerPower * 8;
}

wheelCont.addEventListener('touchstart', (e) => { isSteering = true; handleSteer(e); }, {passive: false});
wheelCont.addEventListener('touchmove', (e) => { if(isSteering) handleSteer(e); }, {passive: false});
wheelCont.addEventListener('touchend', () => { isSteering = false; });

const PLAYLIST_ID = "PLVWEzQMtQoqNxUszzfO0k3lDy_UxddjYy";
for(let i=0; i<15; i++) buildings.push({ x: i*180, w: 70+Math.random()*50, h: 100+Math.random()*150 });

function unlockAudio() {
    document.getElementById('unmute-shield').style.display = 'none';
    if(window.ytPlayer) { window.ytPlayer.unMute(); window.ytPlayer.loadPlaylist({list: PLAYLIST_ID, listType: 'playlist'}); }
}

function onYouTubeIframeAPIReady() {
    window.ytPlayer = new YT.Player('player', { height: '1', width: '1', playerVars: { 'autoplay': 1, 'controls': 0 } });
}

// Action Buttons
const setupAction = (id) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if(id === 'gas') { gear = (gear + 1) % 4; player.targetSpeed = gear * 6; }
        if(id === 'jump' && stage === 1) { if(!player.jumped){ player.dy = -18; player.jumped = true; } }
        if(id === 'drop') {
            let bY = stage === 1 ? player.y + 10 : player.y + player.h;
            bags.push({ x: player.x + (stage===2?5:20), y: bY, w: 15, h: 15, vy: (stage === 2 ? 8 : 0) });
        }
    });
};
['gas','jump','drop'].forEach(setupAction);

function update() {
    if(isGameOver) return;
    player.speed += (player.targetSpeed - player.speed) * 0.05;
    player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));

    if(stage === 1) {
        player.y += player.dy;
        if(player.y + player.h < 380) player.dy += 0.8;
        else { player.y = 380 - player.h; player.dy = 0; player.jumped = false; }
        bgCityX -= player.speed * 0.4;
        
        if(++spawnTimer > 80) {
            enemies.push({ x: canvas.width + 50, y: 350, w: 50, h: 30, c: '#f0f' });
            spawnTimer = 0;
        }
        enemies.forEach((en, i) => {
            en.x -= (player.speed + 3);
            if(player.x < en.x+en.w && player.x+player.w > en.x && player.y < en.y+en.h && player.y+player.h > en.y) {
                if(player.dy > 0 && player.y + player.h < en.y + 20) {
                    enemies.splice(i, 1); player.dy = -18; squashes++;
                    if(squashes >= 10) { stage = 2; player.w = 30; player.h = 60; player.y = 150; enemies = []; bags = []; }
                } else { health -= 10; enemies.splice(i, 1); }
            }
        });
    } else {
        document.getElementById('stg').innerText = "STAGE 2: REAR ATTACK";
        if(++spawnTimer > 50) {
            enemies.push({ x: player.x + (Math.random()*80-40), y: canvas.height + 50, w: 30, h: 50, c: 'white', cop: true });
            spawnTimer = 0;
        }
        enemies.forEach((en, i) => {
            en.y -= (1 + player.speed * 0.6);
            bags.forEach((b, bi) => {
                if(b.x < en.x+en.w && b.x+b.w > en.x && b.y < en.y+en.h && b.y+b.h > en.y) {
                    enemies.splice(i, 1); bags.splice(bi, 1); squashes++;
                }
            });
        });
    }

    bags.forEach((b, i) => { if(stage === 1) b.x -= (player.speed + 4); else b.y += b.vy; });
    document.getElementById('hp').innerText = health + "%";
    document.getElementById('sq').innerText = squashes;
    document.getElementById('gr').innerText = gear;
    if(health <= 0) location.reload();
    
    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if(stage === 1) {
        buildings.forEach(b => {
            let bx = (b.x + bgCityX) % (buildings.length * 180);
            ctx.fillStyle = '#112'; ctx.fillRect(bx, 380 - b.h, b.w, b.h);
            ctx.fillStyle = '#666'; 
            for(let r=0; r<b.h/25; r++) for(let c=0; c<b.w/20; c++) if((r+c)%2===0) ctx.fillRect(bx+5+c*20, 380-b.h+5+r*25, 8, 8);
        });
        ctx.fillStyle = '#222'; ctx.fillRect(0, 380, canvas.width, 70);
    } else {
        ctx.fillStyle = '#111'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#555'; 
        for(let i=0; i<10; i++) ctx.fillRect(canvas.width/2-5, (Date.now()/5%100)+i*100, 10, 40);
    }
    ctx.fillStyle = 'orange'; bags.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
    ctx.fillStyle = '#0ff'; ctx.fillRect(player.x, player.y, player.w, player.h);
    enemies.forEach(en => { ctx.fillStyle = en.c; ctx.fillRect(en.x, en.y, en.w, en.h); });
}
update();
</script>
</body>
</html>
